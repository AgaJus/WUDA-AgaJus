nameOverride: "" # _helpers.tpl – pozwala nadpisać nazwę aplikacji
fullnameOverride: "" # _helpers.tpl – pozwala ustawić pełną nazwę zasobów

namespace: default # wszystkie templates – namespace, do którego trafią zasoby

frontend:
  enabled: true # frontend-deployment.yaml / frontend-service.yaml – czy frontend ma być tworzony

  image:
    repository: frontend # frontend-deployment.yaml – nazwa obrazu Dockera
    tag: latest # frontend-deployment.yaml – tag obrazu
    pullPolicy: Never # frontend-deployment.yaml – polityka pobierania obrazu

  replicas: 1 # frontend-deployment.yaml – liczba replik Deploymentu

  containerPort: 8000 # frontend-deployment.yaml – port, na którym słucha aplikacja w kontenerze

  service:
    type: NodePort # frontend-service.yaml – typ serwisu (NodePort / ClusterIP)
    port: 8000 # frontend-service.yaml – port serwisu
    nodePort: 30080 # frontend-service.yaml – port NodePort widoczny z zewnątrz

  env: # frontend-deployment.yaml – zmienne środowiskowe kontenera
    BACKEND_HOSTNAME: wuda-test-wuda-app-backend
    BACKEND_PORT: "8080" # port backendu
    SECRET_KEY: dev-secret # klucz aplikacyjny
    APP_HOST: "0.0.0.0" # host aplikacji
    APP_PORT: "8000" # port aplikacji
    FLASK_DEBUG: "1"
    PYTHONUNBUFFERED: "1"

  probes: # frontend-deployment.yaml – health checks
    liveness:
      enabled: false
      path: "/" # frontend-deployment.yaml – endpoint liveness
      initialDelay: 60 # frontend-deployment.yaml – opóźnienie startu
      periodSeconds: 10
      timeoutSeconds: 5
      failureThreshold: 5

    readiness:
      enabled: false
      path: "/" # frontend-deployment.yaml – endpoint readiness
      initialDelay: 60 # frontend-deployment.yaml – opóźnienie startu
      periodSeconds: 10
      timeoutSeconds: 3
      failureThreshold: 10

  initContainers:
    - name: wait-for-backend-r
      image: busybox:1.36
      command:
        - sh
        - -c
        - |
          echo "Waiting for backend readiness..."
          until wget -qO- http://wuda-test-wuda-app-backend:8080/readiness; do
            sleep 3
          done
          echo "Backend readiness is up"
  resources:
    requests:
      cpu: "50m"
      memory: "64Mi"
    limits:
      cpu: "200m"
      memory: "128Mi"

backend:
  enabled: true # backend-deployment.yaml / backend-service.yaml – czy backend ma być tworzony

  image:
    repository: backend # backend-deployment.yaml – nazwa obrazu Dockera
    tag: latest # backend-deployment.yaml – tag obrazu
    pullPolicy: Never # backend-deployment.yaml – polityka pobierania obrazu

  replicas: 1 # backend-deployment.yaml – liczba replik

  containerPort: 8080 # backend-deployment.yaml – port aplikacji backendowej

  service:
    type: ClusterIP # backend-service.yaml – typ serwisu backendu
    port: 8080 # backend-service.yaml – port serwisu

  env:
    POSTGRES_HOST: wuda-test-wuda-app-postgres
    POSTGRES_PORT: "5432"
    POSTGRES_DB: games
    APP_HOST: "0.0.0.0"
    APP_PORT: "8080"

  probes:
    startup:
      enabled: false
      path: "/"
      initialDelay: 10
      periodSeconds: 10
      failureThreshold: 30

    liveness:
      enabled: true
      path: "/liveness"
      initialDelay: 5
      periodSeconds: 5
      timeoutSeconds: 5
      failureThreshold: 10

    readiness:
      enabled: true
      path: "/readiness"
      initialDelay: 30
      periodSeconds: 10
      timeoutSeconds: 10
      failureThreshold: 10
  initContainers:
    - name: wait-for-postgres
      image: busybox:1.36
      command:
        - sh
        - -c
        - |
          echo "Waiting for Postgres network availability..."
          MAX_ATTEMPTS=20
          ATTEMPT=0
          until nc -z wuda-test-wuda-app-postgres 5432; do
            ATTEMPT=$((ATTEMPT+1))
            if [ $ATTEMPT -ge $MAX_ATTEMPTS ]; then
              echo "Timeout: Failed to connect to Postgres after 100 seconds."
              exit 1 # Błąd inicjalizacji, restart Poda
            fi
            echo "Attempt $ATTEMPT/$MAX_ATTEMPTS. Waiting 5 seconds..."
            sleep 5
          done
          echo "Postgres is ready on the network layer."
  resources:
    requests:
      cpu: "100m"
      memory: "128Mi"
    limits:
      cpu: "500m"
      memory: "256Mi"

postgres:
  enabled: true # postgres-deployment.yaml / postgres-service.yaml – czy DB ma być tworzona

  image:
    repository: postgres # postgres-deployment.yaml – obraz Postgresa
    tag: "15" # postgres-deployment.yaml – wersja Postgresa
    pullPolicy: IfNotPresent # DODANE: Polityka pobierania obrazu (standard)

  replicas: 1 # postgres-deployment.yaml – liczba replik (zwykle 1)

  service:
    type: ClusterIP # postgres-service.yaml – typ serwisu
    port: 5432 # postgres-service.yaml – port serwisu DB

  env: # postgres-deployment.yaml – zmienne DB
    POSTGRES_DB: games
    POSTGRES_USER: board_games
    POSTGRES_PASSWORD: alamakota

  persistence:
    enabled: false # postgres-deployment.yaml – czy używać trwałego wolumenu
    mountPath: /var/lib/postgresql/data # postgres-deployment.yaml – ścieżka danych

  # DODANE: Health Checks (Probes) dla Postgresa
  probes:
    # Liveness Probe (Sprawdza, czy kontener żyje)
    liveness:
      initialDelaySeconds: 30 # Po ilu sekundach po starcie zacząć sprawdzać
      periodSeconds: 10 # Co ile sekund sprawdzać
      timeoutSeconds: 5 # Czas oczekiwania na odpowiedź
      failureThreshold: 3 # Ile razy musi się nie udać, zanim Pod zostanie zrestartowany

    # Readiness Probe (Sprawdza, czy kontener jest gotowy na ruch)
    readiness:
      initialDelaySeconds: 5 # Postgres startuje szybko, ale potrzebuje chwili na DB
      periodSeconds: 5
      timeoutSeconds: 3
      failureThreshold: 3

kube-prometheus-stack:
  grafana:
    enabled: true

    service:
      type: NodePort
      nodePort: 32000

    dashboards:
      wuda:
        wuda-pods:
          file: dashboards/wuda-pods.json

  prometheus:
    enabled: true
    service:
      type: NodePort
      nodePort: 32001
